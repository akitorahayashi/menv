# This file is generated by the jlo CLI; edits are not recommended.
# Jules Agent Orchestration
#
#
# Orchestrates sequential execution.
# Each phase reads state, generates a matrix, then executes sequentially.
# Role-layer runs stay inside a single job to avoid multiple runners.
#
# Narrator runs first to produce changes context, followed by doctor validation.
# Doctor validation is also handled by jules-automerge.yml as a pre-merge gate.

name: Jules Workflows

on:
  schedule:
    - cron: '0 20 * * *'  # Daily at 20:00 UTC (05:00 JST)
  workflow_dispatch:
    inputs:
      entry_point:
        description: 'Start from layer'
        type: choice
        options:
          - narrator
          - observers
          - deciders
          - planners
          - implementers
          - innovators
        default: narrator
      wait_minutes:
        description: 'Minutes to wait between layers (Jules async processing time)'
        type: number
        default: 30
      routing_labels:
        description: 'Issue labels eligible for planner/implementer routing (comma-separated)'
        type: string
        default: 'bugs,feats,refacts,tests,docs'
      mock:
        description: 'Run in mock mode (creates branches/PRs without Jules API)'
        type: boolean
        default: false

  workflow_call:
    inputs:
      entry_point:
        type: string
        default: narrator
      wait_minutes:
        type: number
        default: 30
      routing_labels:
        type: string
        default: 'bugs,feats,refacts,tests,docs'
      mock:
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: jules
  cancel-in-progress: false

env:
  WAIT_MINUTES: ${{ inputs.wait_minutes || 30 }}
  ROUTING_LABELS: ${{ inputs.routing_labels || 'bugs,feats,refacts,tests,docs' }}
  MOCK_MODE: ${{ inputs.mock || false }}
  JULES_MOCK_TAG: ${{ format('mock-run-{0}', github.run_id) }}
  JLO_RUN_FLAGS: ${{ (inputs.mock || false) && '--mock' || '' }}
  JLO_TARGET_BRANCH: 'main'
  JULES_WORKER_BRANCH: 'jules'


jobs:
  # ============================================================
  # Phase 0: Bootstrap runtime workspace on worker branch
  # ============================================================
  bootstrap:
    if: >-
      (vars.JLO_PAUSED || 'false') != 'true' ||
      github.event_name != 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - name: Validate branch variables
        run: |
          set -euo pipefail
          if [ -z "${JLO_TARGET_BRANCH:-}" ]; then
            echo "::error::JLO_TARGET_BRANCH is required."
            exit 1
          fi
          if [ -z "${JULES_WORKER_BRANCH:-}" ]; then
            echo "::error::JULES_WORKER_BRANCH is required."
            exit 1
          fi

      - uses: actions/checkout@v4
        with:
          ref: 'main'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Ensure worker branch
        run: |
          set -euo pipefail
          if git ls-remote --exit-code --heads origin "${JULES_WORKER_BRANCH}" >/dev/null 2>&1; then
            echo "${JULES_WORKER_BRANCH} branch exists, checking out"
            git fetch origin "${JULES_WORKER_BRANCH}" --depth=1
            git checkout -B "${JULES_WORKER_BRANCH}" "origin/${JULES_WORKER_BRANCH}"
          else
            echo "Creating ${JULES_WORKER_BRANCH} from ${JLO_TARGET_BRANCH}"
            git checkout -B "${JULES_WORKER_BRANCH}" "origin/${JLO_TARGET_BRANCH}"
          fi

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Bootstrap runtime workspace
        run: jlo workflow bootstrap

      - name: Commit and push changes
        id: bootstrap
        run: |
          set -euo pipefail
          if [ -n "$(git status --porcelain .jules)" ]; then
            git add .jules/
            git commit -m "chore: bootstrap .jules/ runtime workspace [jlo $(jlo --version | awk '{print $2}')]"
            git push origin "${JULES_WORKER_BRANCH}"
            echo "committed=true" >> "$GITHUB_OUTPUT"
          else
            echo "committed=false" >> "$GITHUB_OUTPUT"
          fi


  # ============================================================
  # Phase 1: Run narrator (changes feed generation)
  # ============================================================
  run-narrator:
    needs: [bootstrap]
    if: >-
      needs.bootstrap.result == 'success' &&
      ((vars.JLO_PAUSED || 'false') != 'true' || github.event_name != 'schedule') &&
      (
        github.event_name == 'schedule' ||
        (github.event_name == 'workflow_dispatch' && (github.event.inputs.entry_point || 'narrator') == 'narrator') ||
        (github.event_name == 'workflow_call' && (inputs.entry_point || 'narrator') == 'narrator')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run narrator
        id: run
        run: jlo workflow run global narrator ${{ env.JLO_RUN_FLAGS }}

      - name: Validate workspace (fail-fast)
        run: jlo doctor


  # ============================================================
  # Phase 2: Wait for narrator processing
  # ============================================================

  wait-after-narrator:
    needs: run-narrator
    if: |
      always() &&
      needs.run-narrator.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "narrator" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process narrator..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 3: Generate workstream matrix
  # ============================================================
  generate-workstream-matrix:
    needs: wait-after-narrator
    if: |
      always() &&
      ((vars.JLO_PAUSED || 'false') != 'true' || github.event_name != 'schedule') &&
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call') &&
      (needs.wait-after-narrator.result == 'success' || needs.wait-after-narrator.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Generate workstream matrix
        id: matrix
        run: jlo workflow matrix workstreams


  # ============================================================
  # Phase 4: Run innovators (first pass - idea creation)
  # ============================================================

  run-innovators-1:
    needs: [generate-workstream-matrix]
    if: |
      always() &&
            needs.generate-workstream-matrix.result == 'success' &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run innovators (first pass) for each workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running innovators for workstream: $ws"
            jlo workflow run "$ws" innovators ${{ env.JLO_RUN_FLAGS }} --phase creation
          done
  # ============================================================
  # Phase 5: Run observers
  # ============================================================

  run-observers:
    needs: [generate-workstream-matrix]
    if: |
      always() &&
            needs.generate-workstream-matrix.result == 'success' &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run observers for each workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running observers for workstream: $ws"
            jlo workflow run "$ws" observers ${{ env.JLO_RUN_FLAGS }}
          done
  # ============================================================
  # Phase 6: Wait for observer processing
  # ============================================================

  wait-after-observers:
    needs: run-observers
    if: |
      always() &&
      needs.run-observers.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "observers" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process observers..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 7: Wait for innovator processing (first pass)
  # ============================================================

  wait-after-innovators-1:
    needs: run-innovators-1
    if: |
      always() &&
      needs.run-innovators-1.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "innovators (first pass)" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process innovators (first pass)..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 8: Run innovators (second pass - proposal and cleanup)
  # ============================================================

  run-innovators-2:
    needs: ["generate-workstream-matrix", "wait-after-observers", "wait-after-innovators-1"]
    if: |
      always() &&
            fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
            (needs.wait-after-observers.result == 'success' || needs.wait-after-observers.result == 'skipped') &&
            (needs.wait-after-innovators-1.result == 'success' || needs.wait-after-innovators-1.result == 'skipped')

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run innovators (second pass) for each workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running innovators for workstream: $ws"
            jlo workflow run "$ws" innovators ${{ env.JLO_RUN_FLAGS }} --phase refinement
          done
  # ============================================================
  # Phase 9: Wait for innovator processing (second pass)
  # ============================================================

  wait-after-innovators-2:
    needs: run-innovators-2
    if: |
      always() &&
      needs.run-innovators-2.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "innovators (second pass)" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process innovators (second pass)..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 10: Publish innovator proposals as GitHub issues
  # ============================================================
  publish-proposals:
    needs: [generate-workstream-matrix, wait-after-innovators-2]
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.wait-after-innovators-2.result == 'success' || needs.wait-after-innovators-2.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Publish proposals for each workstream
        env:
          WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$WORKSTREAMS_OUTPUT" | jq -r '.matrix.include[].workstream' | while read -r ws; do
            echo "Publishing proposals for workstream: $ws"
            jlo workflow workstreams publish-proposals "$ws"
          done


  # ============================================================
  # Phase 11: Generate decider matrix (pending events check)
  # ============================================================
  generate-decider-matrix:
    needs: [generate-workstream-matrix, wait-after-observers]
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.wait-after-observers.result == 'success' || needs.wait-after-observers.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Generate decider matrix from pending events
        id: matrix
        env:
          WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          WORKSTREAMS_JSON=$(echo "$WORKSTREAMS_OUTPUT" | jq -c '.matrix')
          jlo workflow matrix pending-workstreams --workstreams-json "$WORKSTREAMS_JSON"


  # ============================================================
  # Phase 12: Run deciders
  # ============================================================

  run-deciders:
    needs: [generate-decider-matrix]
    if: |
      always() &&
            needs.generate-decider-matrix.result == 'success' &&
            fromJSON(needs.generate-decider-matrix.outputs.json).has_pending == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run deciders for each pending workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-decider-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.matrix.include[].workstream' | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running deciders for workstream: $ws"
            jlo workflow run "$ws" deciders ${{ env.JLO_RUN_FLAGS }}
          done
  # ============================================================
  # Phase 13: Wait for decider processing
  # ============================================================

  wait-after-deciders:
    needs: run-deciders
    if: |
      always() &&
      needs.run-deciders.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "deciders" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process deciders..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 14: Generate routing matrices (new issues)
  # ============================================================
  generate-planner-matrix:
    needs: [generate-workstream-matrix, generate-decider-matrix, run-deciders, wait-after-deciders]
    if: |
      always() &&
      fromJSON(needs.generate-workstream-matrix.outputs.json).has_workstreams == true &&
      (needs.generate-decider-matrix.result == 'success' || needs.generate-decider-matrix.result == 'skipped') &&
      (needs.run-deciders.result == 'success' || needs.run-deciders.result == 'skipped') &&
      (needs.wait-after-deciders.result == 'success' || needs.wait-after-deciders.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.matrix.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Generate planner and implementer matrices
        id: matrix
        env:
          WORKSTREAMS_OUTPUT: ${{ needs.generate-workstream-matrix.outputs.json }}
        run: |
          WORKSTREAMS_JSON=$(echo "$WORKSTREAMS_OUTPUT" | jq -c '.matrix')
          jlo workflow matrix routing --workstreams-json "$WORKSTREAMS_JSON" --routing-labels "$ROUTING_LABELS"


  # ============================================================
  # Phase 15: Run planners
  # ============================================================

  run-planners:
    needs: [generate-planner-matrix]
    if: |
      always() &&
            needs.generate-planner-matrix.result == 'success' &&
            fromJSON(needs.generate-planner-matrix.outputs.json).has_planners == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run planners for each workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-planner-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.planner_matrix.include[].workstream // empty' | sort -u | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running planners for workstream: $ws"
            jlo workflow run "$ws" planners ${{ env.JLO_RUN_FLAGS }}
          done
  # ============================================================
  # Phase 16: Wait for planner PRs
  # ============================================================

  wait-after-planners:
    needs: run-planners
    if: |
      always() &&
      needs.run-planners.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "planners" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process planners..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 17: Run implementers
  # ============================================================

  run-implementers:
    needs: [generate-planner-matrix]
    if: |
      always() &&
            needs.generate-planner-matrix.result == 'success' &&
            fromJSON(needs.generate-planner-matrix.outputs.json).has_implementers == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
      TARGET_BRANCH: 'main'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo

      - name: Run implementers for each workstream
        id: run
        env:
          MATRIX_OUTPUT: ${{ needs.generate-planner-matrix.outputs.json }}
        run: |
          set -euo pipefail
          echo "$MATRIX_OUTPUT" | jq -r '.implementer_matrix.include[].workstream // empty' | sort -u | while read -r ws; do
            [ -z "$ws" ] && continue
            echo "Running implementers for workstream: $ws"
            jlo workflow run "$ws" implementers ${{ env.JLO_RUN_FLAGS }}
          done
  # ============================================================
  # Phase 18: Wait for implementer labels
  # ============================================================

  wait-after-implementers:
    needs: run-implementers
    if: |
      always() &&
      needs.run-implementers.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          trap 'echo "Cancellation detected. Exiting wait early."; exit 130' INT TERM

          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=30
            echo "Mock mode enabled: overriding wait to 30 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -n "implementers" ]; then
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process implementers..."
          else
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process..."
          fi
          ELAPSED=0
          INTERVAL=5
          while [ $ELAPSED -lt $TOTAL_SECONDS ]; do
            STEP=$INTERVAL
            REMAINING=$((TOTAL_SECONDS - ELAPSED))
            if [ "$REMAINING" -lt "$STEP" ]; then
              STEP=$REMAINING
            fi
            sleep "$STEP" &
            wait $!
            ELAPSED=$((ELAPSED + STEP))
            echo "[$ELAPSED/$TOTAL_SECONDS seconds]"
          done
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
